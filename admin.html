<script>
    // --- DOM elements ---
    const loginView = document.getElementById('login-view');
    const adminView = document.getElementById('admin-view');
    const passwordInput = document.getElementById('password');
    const loginButton = document.getElementById('login-button');
    const loginError = document.getElementById('login-error');
    const jsonEditor = document.getElementById('json-editor');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const productSelector = document.getElementById('product-selector');
    const editForm = document.getElementById('edit-form');
    const saveGitHubButton = document.getElementById('save-github-button');
    const saveStatus = document.getElementById('save-status');
    const flagsTableBody = document.getElementById('flags-table-body');


    // Check for existing token
    const token = localStorage.getItem('jwt_token');
    if (token) {
        loginView.classList.add('hidden');
        adminView.classList.remove('hidden');
        loadAdminData();
    }

    loginButton.addEventListener('click', async () => {
        const password = passwordInput.value;
        loginError.classList.add('hidden');
        try {
            const response = await fetch('/api/admin-login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password })
            });
            if (!response.ok) throw new Error('Login failed');
            const { token } = await response.json();
            localStorage.setItem('jwt_token', token);
            loginView.classList.add('hidden');
            adminView.classList.remove('hidden');
            loadAdminData();
        } catch (error) {
            loginError.textContent = 'Invalid password.';
            loginError.classList.remove('hidden');
        }
    });

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('border-indigo-500', 'text-indigo-600'));
            tab.classList.add('border-indigo-500', 'text-indigo-600');
            tabContents.forEach(content => {
                content.id === `${tab.dataset.tab}-content` ? content.classList.remove('hidden') : content.classList.add('hidden');
            });
        });
    });

    async function loadAdminData() {
        loadLiveEditor();
        loadFlags();
        loadRatings();
    }

    async function loadLiveEditor() {
        try {
            const response = await fetch('../assets/products.json');
            const products = await response.json();
            jsonEditor.value = JSON.stringify(products, null, 2);
            populateProductSelector(products);
        } catch (error) {
            console.error('Error loading products.json:', error);
            jsonEditor.value = 'Error loading products.json.';
        }
    }

    saveGitHubButton.addEventListener('click', async () => {
        if (!confirm('Are you sure you want to save these changes directly to the live site?')) {
            return;
        }
        saveStatus.classList.remove('hidden', 'text-green-600', 'text-red-600');
        saveStatus.textContent = 'Saving to GitHub...';
        saveGitHubButton.disabled = true;
        const token = localStorage.getItem('jwt_token');
        const content = jsonEditor.value;
        try {
            JSON.parse(content); // Validate JSON
            const response = await fetch('/api/update-products', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ content })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || 'Failed to save.');
            }
            const result = await response.json();
            saveStatus.textContent = result.message;
            saveStatus.classList.add('text-green-600');
        } catch (error) {
            saveStatus.textContent = `Error: ${error.message}`;
            saveStatus.classList.add('text-red-600');
            if (error instanceof SyntaxError) {
                saveStatus.textContent = 'Error: The content is not valid JSON.';
            }
        } finally {
            saveGitHubButton.disabled = false;
        }
    });

    // --- UPDATED FLAGS FUNCTIONALITY ---
    async function loadFlags() {
        const flagsLoading = document.getElementById('flags-loading');
        const flagsError = document.getElementById('flags-error');
        flagsLoading.classList.remove('hidden');
        flagsError.classList.add('hidden');
        flagsTableBody.innerHTML = '';

        try {
            const token = localStorage.getItem('jwt_token');
            if (!token) throw new Error('Not authenticated');

            const [flagsResponse, productsResponse] = await Promise.all([
                fetch('/api/get-flags', { headers: { 'Authorization': `Bearer ${token}` } }),
                fetch('../assets/products.json')
            ]);
            
            if (!flagsResponse.ok) throw new Error(`Failed to fetch flags. Status: ${flagsResponse.status}`);
            
            const flags = await flagsResponse.json();
            const products = await productsResponse.json();
            const productMap = products.reduce((acc, p) => {
                acc[p.id] = p.name;
                return acc;
            }, {});

            // Aggregate flags by both productId and reason
            const flagGroups = flags.reduce((acc, flag) => {
                const key = `${flag.productId}::${flag.reason}`;
                if (!acc[key]) {
                    acc[key] = {
                        productId: flag.productId,
                        reason: flag.reason,
                        count: 0
                    };
                }
                acc[key].count++;
                return acc;
            }, {});

            flagsTableBody.innerHTML = ''; // Clear existing rows
            Object.values(flagGroups).forEach(group => {
                const productName = productMap[group.productId] || 'Unknown Product';
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-6">${productName}</td>
                    <td class="whitespace-nowrap px-3 py-4 text-sm text-gray-500">${group.reason}</td>
                    <td class="whitespace-nowrap px-3 py-4 text-sm text-gray-500">${group.count}</td>
                    <td class="relative whitespace-nowrap py-4 pl-3 pr-4 text-right text-sm font-medium sm:pr-6">
                        <button class="text-indigo-600 hover:text-indigo-900 resolve-btn">Resolve</button>
                    </td>
                `;
                // Add data attributes to the button for the event listener
                const resolveButton = row.querySelector('.resolve-btn');
                resolveButton.dataset.productId = group.productId;
                resolveButton.dataset.reason = group.reason;
                flagsTableBody.appendChild(row);
            });

        } catch (error) {
            console.error('Error loading flags:', error);
            flagsError.classList.remove('hidden');
        } finally {
            flagsLoading.classList.add('hidden');
        }
    }

    // New event listener for resolving flags
    flagsTableBody.addEventListener('click', async (event) => {
        if (event.target.classList.contains('resolve-btn')) {
            const button = event.target;
            const { productId, reason } = button.dataset;
            
            if (!confirm(`Are you sure you want to resolve all "${reason}" flags for this product?`)) {
                return;
            }

            button.textContent = 'Resolving...';
            button.disabled = true;
            
            try {
                const token = localStorage.getItem('jwt_token');
                const response = await fetch('/api/resolve-flag', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ productId, reason })
                });

                if (!response.ok) {
                    throw new Error('Failed to resolve flags.');
                }
                // Success, remove the row from the UI
                button.closest('tr').remove();

            } catch (error) {
                console.error('Resolve flag error:', error);
                alert('An error occurred. Please try again.');
                button.textContent = 'Resolve';
                button.disabled = false;
            }
        }
    });
    
    async function loadRatings() {
        // ... (this function remains unchanged)
    }

    function populateProductSelector(products) {
        // ... (this function remains unchanged)
    }

    productSelector.addEventListener('change', async (e) => {
        // ... (this function remains unchanged)
    });

    document.getElementById('save-edit-button').addEventListener('click', () => {
        // ... (this function remains unchanged)
    });
</script>
